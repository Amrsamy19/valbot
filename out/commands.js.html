<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: commands.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: commands.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const { RichEmbed } = require('discord.js')

/**
 * @typedef {Class} Message
 * @description Discord Message Class
 * @see {@link https://discord.js.org/#/docs/main/stable/class/Message}
 */

/**
 * @since 1.0.0
 * @type {Object}
 */
let BOT_COMMANDS =  {
  /**
   * @since 1.0.0
   * @type {Object}
   * @memberof! BOT_COMMANDS
   */
  org: {
    /**
    * @since 1.0.0
    * @method
    * @param {Message} commandMessage The command message containing command parameters
    * @param {Array} args `commandMessage` split using String.prototype.split(' ')
    * @param {Object} __ENV
    * @see {@link https://discord.js.org/#/docs/main/stable/class/Message}
    * @memberof! org
    */
    mute: async (commandMessage, args, __ENV)=>{
      try{
        let mutedMember = await __ENV.__VALARIUM_GUILD().fetchMember(args[3].toString().replace(/&lt;|>|@/ig, ''))
        let slicedReason = args.slice(5).join(' ') || 'Violation of the rules'
        let date = new Date().toString()
        
        mutedMember.addRole('586839490102951936', args[4])
        console.log(mutedMember.roles.some(role => role.id === '586839490102951936'))
        !mutedMember.roles.some(role => role.id === '586839490102951936') ? mutedMember.addRole('586839490102951936'): commandMessage.reply('this user is already muted')

        BOT_COMMANDS.helpers.sendEmbedNotification(
          __ENV, undefined, 
          {
            author: commandMessage.author, 
            description: `${mutedMember} has been muted at ${date} by ${commandMessage.member}`, 
            title:`INFO, ${mutedMember}`, 
            color: 0xfade78,
            footer: date
          }, [
            {name: 'Member', value: `${mutedMember}`}, 
            {name: 'Moderator', value: `${commandMessage.member}`}, 
            {name: 'Reason', value: slicedReason}, 
            {name: 'Status', value: `This user is now muted and will be automatically unmuted in 15 minutes`}
          ], 
          undefined, 
          [__ENV.__MODERATION_NOTICES_CHANNEL()])
        
        setTimeout(()=>{BOT_COMMANDS.org.unmute(commandMessage, args, __ENV)}, 900000) //15 minutes 900000 ms
      }
      catch(err){console.log(err)}
    },
    unmute: async (commandMessage, args, __ENV)=>{
      try{
        let mutedMember = await __ENV.__VALARIUM_GUILD().fetchMember(args[3].toString().replace(/&lt;|>|@/ig, ''))
        let date = new Date().toString()
        console.log(mutedMember.roles.some(role => role.id === '586839490102951936'))
        mutedMember.roles.some(role => role.id === '586839490102951936')? mutedMember.removeRole('586839490102951936'): commandMessage.reply('this user is not muted')
        
        BOT_COMMANDS.helpers.sendEmbedNotification(
          __ENV, undefined, 
          {
            author: commandMessage.author, 
            description: `${mutedMember} has been unmuted at ${date} by ${commandMessage.member}`, 
            title:`INFO, ${mutedMember}`, 
            color: 0xfade78,
            footer: date
          }, [
            {name: 'Member', value: `${mutedMember}`}, 
            {name: 'Moderator', value: `${commandMessage.member}`}, 
            {name: 'Status', value: `This user is now unmuted. Happy talking!`}
          ], 
          undefined, 
          [__ENV.__MODERATION_NOTICES_CHANNEL()])
      }
      catch(err){console.log(err)}
    }
  },
  mod: {
    allowedRoles: [
      '571716246660448318', //President
      '571705643073929226', //Leaders
    ],
    clear: async (commandMessage, args, __ENV)=>{
      try{
        let deletedMessages = await commandMessage.channel.bulkDelete(args[3]? parseInt(args[3]): 5)
        deletedMessages = deletedMessages.map(message=>({author: {name: message.author.username, id: message.author.id}, content: message.content}))
        await __ENV.__DATABASE_OBJECT.collection('DELETED_MESSAGES').insertMany(deletedMessages)
      }
      catch(err){
        console.log(err)
      }
    },
    warn: async (commandMessage, args, __ENV)=>{
      try{
        let warnedMember = await __ENV.__VALARIUM_GUILD().fetchMember(args[3].toString().replace(/&lt;|>|@/ig, ''))
        let slicedReason = args.slice(5).join(' ')

        let userWarnings = (await __ENV.__DATABASE_OBJECT.collection('GUILD_WARNINGS').findOneAndUpdate({USER_ID: warnedMember.id}, {
          '$push': { 
            RECORDED_WARNINGS: {
              WARNING_REASON_NAME: args[4],
              WARNING_REASON_DESCRIPTION: slicedReason,
              WARNING_DATE: new Date().toString()
            }   
          }
        }, {upsert: true, returnOriginal: false})).value

        let date = new Date().toString()
        
        BOT_COMMANDS.helpers.sendEmbedNotification(
          __ENV, warnedMember, 
          {
            author: commandMessage.author, 
            description: `${warnedMember} has been warned at ${date} by ${commandMessage.member}`, 
            title:`WARNING, ${warnedMember}`, 
            color: 0xfade78,
            footer: date
          }, [
            {name: 'Member', value: `${warnedMember}`}, 
            {name: 'Moderator', value: `${commandMessage.member}`}, 
            {name: 'Reason', value: slicedReason}, 
            {name: 'Status', value: `This user now has ${userWarnings.RECORDED_WARNINGS.length} warnings`}
          ], 
          [], 
          [__ENV.__MODERATION_NOTICES_CHANNEL()])

        if(userWarnings.RECORDED_WARNINGS.length === 3){
          BOT_COMMANDS.mod.ban(commandMessage, args, __ENV, 'Warned 3 times')
        }
      }
      catch(err){console.log(err)}
    },
    warnings: async (commandMessage, args, __ENV)=>{
      try{
        let warnedMember = await __ENV.__VALARIUM_GUILD().fetchMember(args[3].toString().replace(/&lt;|>|@/ig, ''))
        let userWarnings = await BOT_COMMANDS.helpers.getWarnings(warnedMember, __ENV)
        let fields = []

        if(userWarnings &amp;&amp; userWarnings.RECORDED_WARNINGS){
          fields = userWarnings.RECORDED_WARNINGS.map(( warning => ({name: warning.WARNING_REASON_NAME, value:
            warning.WARNING_REASON_DESCRIPTION})))
        }
        
        BOT_COMMANDS.helpers.sendEmbedNotification(
          __ENV, undefined,
          {
            author: commandMessage.author,  
            title:`WARNING LOG, ${warnedMember}`, 
            color: 0xfade78
          }, [
            ...fields,
            {name: 'Member', value: `${warnedMember}`}, 
            {name: 'Moderator', value: `${commandMessage.member}`}, 
            {name: 'Status', value: `This user has ${userWarnings.RECORDED_WARNINGS.length} warnings`}
          ], 
          undefined, 
          [commandMessage.channel], (embed)=>{commandMessage.reply(embed)})
      }
      catch(err){console.log(err)}
    },
    reactionRoles: (commandMessage, args, __ENV)=>{
      try{
        commandMessage.guild.channels.find(ch => `&lt;#${ch.id}>` === args[3]).fetchMessage(args[4]).then(reactionMessage=>{
          let index = 0 
          let expectedReaction = {}
          let botMessage
          let originalCommand = commandMessage.content.toString()

          const inputCollector = commandMessage.createReactionCollector(reaction => reaction)
          commandMessage.reply('please react to the previous message with the reaction you want!')
            .then(sent=>botMessage=sent)
            .catch(console.error)

          inputCollector.on('collect', async reaction=>{
            expectedReaction.name = reaction.emoji.name
            botMessage.edit('What\'s the expected role for that reaction? Update your message to reflect that!')

            __ENV.__VALARIUM_CLIENT.on('messageUpdate', (oldMessage, newMessage)=>{
              if(oldMessage.content === originalCommand){
                if(__ENV.__AVAILABLE_ROLES.find(role => role.name === newMessage.content)){
                  reactionMessage.react(reaction.emoji.name)
                  botMessage.edit('Successful. Awaiting reactions.')
                  expectedReaction.role = newMessage.content
                  const userReactionsCollector = reactionMessage.createReactionCollector(reaction=>reaction.emoji.name === expectedReaction.name)
                  __ENV.__DATABASE_OBJECT.collection('WATCHED_MESSAGES').updateOne({
                    CHANNEL_ID: reactionMessage.channel.id,
                    MESSAGE_ID: reactionMessage.id
                  },{
                    '$addToSet': { 
                      WATCHED_REACTIONS: {
                        REACTION_NAME: reaction.emoji.name,
                        REACTION_ROLE_ID: __ENV.__AVAILABLE_ROLES.find(role => role.name === newMessage.content).id,
                        REACTION_ROLE_NAME: newMessage.content
                      } 
                    }
                  }, {upsert: true})
                  userReactionsCollector.on('collect', reaction=>{
                    reaction.fetchUsers()
                      .then(users=>{
                        users.forEach(user=>{
                          reactionMessage.guild.fetchMember(user.id)
                            .then(member=>{
                              let currentRole = __ENV.__AVAILABLE_ROLES.find(role => role.name === newMessage.content)
                              member.addRole(currentRole.id)
                              BOT_COMMANDS.notifications.DMUser(member, `You've been granted role [${currentRole.name}]`)
                              //TODO: LOAD AND COLLECT MESSAGES UPON FETCH FROM DATABASE
                            })
                        })
                      })
                  })
                }
                else{
                  commandMessage.reply('that role was not found')
                }
              }
            })
          })
        })
      }
      catch(err){
        console.error(err)
      }
    },
    ban: async function(commandMessage, args, __ENV, reason){
      try{
        let bannedMember = await __ENV.__VALARIUM_GUILD().fetchMember(args[3].toString().replace(/&lt;|>|@/ig, ''))
        let userWarnings = BOT_COMMANDS.mod.warnings(commandMessage, args, __ENV)
        let date = new Date().toString()

        bannedMember.ban({days: 3, reason})
        
        BOT_COMMANDS.helpers.sendEmbedNotification(__ENV, bannedMember, 
          {
            author: commandMessage.author, 
            description: `${bannedMember} has been warned at ${date} by ${commandMessage.member}`, 
            title:`BAN, ${bannedMember}`, 
            color: 0xfade78,
            footer: date
          }, [
            {name: 'Member', value: `${bannedMember}`}, 
            {name: 'Moderator', value: `${commandMessage.member}`}, 
            {name: 'Reason', value: reason}, 
            {name: 'Status', value: userWarnings.RECORDED_WARNINGS.length === 3? 'This user is now banned': `This user now has ${userWarnings.RECORDED_WARNINGS.length} warnings`}
          ], )
      }
      catch(err){ console.log(err) }
    },
    unban: async function(commandMessage, args, __ENV, reason){
      try{
        let bannedMember = await __ENV.__VALARIUM_CLIENT.fetchUser(args[3].toString().replace(/&lt;|>|@/ig, ''), {cache: true})

        await __ENV.__VALARIUM_GUILD().unban(bannedMember, reason)

        BOT_COMMANDS.helpers.sendEmbedNotification(__ENV, bannedMember, { 
          author: 'VALARIUM', description: 'You\'ve been unbanned from Valarium. Enjoy your stay :tada::hugging:!', title:'NOTIFICATION FROM VALARIUM', color: 0xfade78
        }, [{name: 'Mod: ', value: commandMessage.author}])
      }
      catch(err){console.log(err)}
    },
  },
  helpers:{
    sendEmbedNotification: async function(__ENV, member = undefined, embedOptions, fields, attachments = undefined, channels = undefined, callback){
      try{
        let embed = new RichEmbed(embedOptions)
        if(fields.length > 0){
          fields.forEach(field => field.name==='Moderator' || field.name==='Member'? embed.addField(field.name, field.value, true): embed.addField(field.name, field.value))
        }
        if(attachments){
          attachments.forEach(attachment=>{
            embed.attachFile(attachment.path)
          })
        }
        embed.setThumbnail('https://lh4.googleusercontent.com/Yic_fQ7O-bo2q1ELjzBTQaR3ljVG-coyKsj87E55QzuxrH4b0K1F2ZchjFVrQ_QBA93fc1xWczkD7LGPMTsO')
        if(channels){
          channels.forEach(channel=>{
            channel.send(embed)
          })
        }
        if(member){
          let DMChannel = await member.createDM()
          DMChannel.send(embed)
        }
        if(callback){
          callback(embed)
        }
      }
      catch(err){console.log(err)}
    },
    getWarnings: async (warnedMember, __ENV)=>{
      try{
        let warnings = await __ENV.__DATABASE_OBJECT.collection('GUILD_WARNINGS').findOne({USER_ID: warnedMember.id})
        return warnings
      }
      catch(err){console.log(err)}
    }
  }
}

module.exports = BOT_COMMANDS</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#BOT_COMMANDS">BOT_COMMANDS</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Tue Jun 11 2019 14:42:51 GMT+0200 (Eastern European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
